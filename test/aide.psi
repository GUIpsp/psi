// skipped

import genCap;
import hmm;

def log‚ÇÇ(x)=>log(x)/log(2);

def H_cross[a](p: Distribution[a], q: Distribution[a], eq: a√óa‚Üíùîπ)‚áí
	expectation(infer(()‚áí S(q,sample(p),eq)));

def KL[a](p: Distribution[a], q: Distribution[a], eq: a√óa‚Üíùîπ)‚áí
	H_cross(p,q,eq)-H(p,eq);

/+
def sym_KL[a](p: Distribution[a], q: Distribution[a], eq: a√óa‚Üíùîπ)‚áí
	KL(p,q,eq)+KL(q,p,eq);
+/

a := [[0.6,0.4], // transitions
	  [0.7,0.3]];
b := [[0.5,0.5],[0.2,0.8]]; // hidden ‚Üí observed
def makeHMM()‚áíHMM(a,b,0);

seq:=[-1,-1,0,-1,1,-1];

def exact()‚áíinfer((){
	h:=makeHMM();
	for i in [0..seq.length){
		if seq[i]==-1{
			h.update();
		}else{
			observe(h.predict()==seq[i]);
		}
	}
	return h.x;
});

def filter(n:‚Ñï){
	particles:=array(n,0);
	weights:=array(n,1.0);
	for i in [0..seq.length){
		if seq[i]==-1{
			for j in [0..n){
				particles[j]=categorical(a[particles[j]]);
			}
		}else{
			for j in [0..n){
				weights[j]*=b[particles[j]][seq[i]];
			}
		}
	}
	sum:=0.0;
	for j in [0..n){ sum+=weights[j]; }
	for j in [0..n){ weights[j]/=sum; }
	return infer(()=>particles[categorical(weights)]);
}

def main(){
	q:=exact();
	r‚ÇÅ:=Expectation(KL(filter(1),q,(a:‚Ñï,b:‚Ñï)‚áía=b));
	r‚ÇÇ:=Expectation(KL(filter(2),q,(a:‚Ñï,b:‚Ñï)‚áía=b));
	r‚ÇÉ:=Expectation(KL(filter(3),q,(a:‚Ñï,b:‚Ñï)‚áía=b));
	r‚ÇÑ:=Expectation(KL(filter(4),q,(a:‚Ñï,b:‚Ñï)‚áía=b));
	return (r‚ÇÅ,r‚ÇÇ,r‚ÇÉ,r‚ÇÑ);
}
